---
title: CSAPP之链接
tags:
  - CSAPP
toc: true
date: 2017-11-09 21:25:54
---
# 前言
链接就是将代码和数据组合成一个单一文件的过程，组成的文件可以被加载到内存并执行。链接可以执行于编译时，也可以执行于加载时，甚至执行于运行时。链接在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能，我们可以将一个大型的应用程序分解为更小更好管理的模块，并且独立的修改和编译这些模块，当我们修改这些模块中的一个时只需要重新编译它，并重新链接应用，而不必重新编译其他文件。

# 编译器驱动程序
在将源代码编译成可执行程序时，会经历如下步骤：首先，运行预处理器将源程序翻译成一个ASCII码的中间文件；然后，运行C编译器将中间文件翻译成一个汇编文件；再运行汇编器将汇编文件翻译成可重定位目标文件；最后，运行链接程序将可重定位目标文件以及一些必要的系统目标文件组合起来，创建一个可执行目标文件。
``` bash
cpp sum.c /tmp/sum.i #预处理
/usr/lib/gcc/x86_64-linux-gnu/5/cc1 /tmp/sum.i -Og -o /tmp/sum.s #编译
as -o /tmp/sum.o /tmp/sum.s #汇编
ld -o prog /tmp/main.o /tmp/sum.o #链接
```
<!--more-->
<center>![avatar](http://oyh38rhr2.bkt.clouddn.com/github/171109/A04eBDGA1j.jpg)</center>

# 静态链接
链接器的主要任务：
>符号解析  符号解析就是将每个符号引用和一个符号定义关联起来
重定位  编译器和汇编器生成从地址0开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

# 可重定位目标文件
.bss节：未初始化的全局变量，和静态变量以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占实际空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量，不需要占用任何实际的磁盘空间。运行时在内存中分配这些变量，初始值为0。所以，一种区分.data和.bss节的简单方式就是把`bss`看成是“更好地节省空间(Better Save Sapce)”的缩写。现代的GCC版本根据以下规则将可重定位目标文件的符号分配到COMMON和.bss中：
>COMMON   未初始化的全局变量
.bss     未初始化的静态变量以及初始化为0的全局或静态变量

可重定位目标文件格式如下：
<center>![avatar](http://oyh38rhr2.bkt.clouddn.com/github/171109/ia5cF7fIGk.jpg)</center>

# 符号解析
链接器对重载函数的区分是通过重整(mangling)实现，编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。
每个定义符号在代码段或数据段中都被分配了存储空间，`将引用符号与对应定义符号建立关联后，就可在重定位时将引用符号的地址重定位为相关联的定义符号的地址`。“符号的定义”其实质就是符号被分配了虚拟地址空间，符号为函数名时指代码所在区；符号为变量即指其占的静态数据区。
强符号和弱符号定义：
>函数和已经初始化的全局变量是强符号，
未初始化的全局变量是弱符号

多重定义符号的处理规则：
>Rule 1: 强符号不能多次定义；强符号只能被定义一次，否则链接错误
Rule 2: 若一个符号被定义为一次强符号和多次弱符号，则按强定义为准
Rule 3: 若有多个弱符号定义，则任选其中一个

规则2和规则3的应用会造成一些不易察觉的运行时错误，尤其是如果重复的符号定义还有不同的类型。当怀疑有此类错误时，在GCC中使用`-fno-common`的选项调用链接器，这个选项会告诉链接器在遇到多重定义的符号时，触发一个错误。或者使用`-Werror`选项，它会把所有的警告都变为错误。多重定义导致难以察觉错误示例:
<center>![avatar](http://oyh38rhr2.bkt.clouddn.com/github/171110/bLLL6Hadaj.jpg)</center>

# 静态库链接
把函数编译为独立的目标模块，然后封装成一个单独的静态库。在Linux系统中，静态库以一种称为存档(archive)的文件格式存放在磁盘中，存档文件是一些可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置，存档文件名由后缀.a标识。所以应用程序员只要包含较少的库文件的名字，在链接时链接器只复制被应用程序引用的目标模块，从而减少了可执行文件在磁盘和内存中的大小。
关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的，那么这些库就可以以任意的顺序放在命令行的结尾处；如果不是相互独立的，那么必须对它们排序，使得对于每个被静态库的外部成员引用的符号s，在命令行中至少有一个s的定义是在s的引用之后。在某些情况下，为了满足依赖需求，需要重复包含库或者将多个库合并成一个库。

# 重定位
